# 异步编程

## 函数式编程
+ 高阶函数
  + 高阶函数可以把函数作为参数，或者将函数作为返回值的函数。

## 异步编程的优势与难点
+ 优势
  + Node 利用 Javascript 及其内部异步库，将异步直接提升到业务层面，这是一种创新。
  + 非阻塞 I/O 可以使 CPU 与 I/O 并不相互依赖等待，让资源得到更好的利用。
  + 只要合理利用 Node 的异步模型和 V8 的高性能，就可以充分发挥 CPU 和 I/O 资源的优势。
+ 难点
  + 异常处理
    + Node 在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出。
  + 函数嵌套过深
  + 阻塞代码
  + 多线程编程
    + 对于服务端而言，如果服务器是多核 CPU，单个 Node 进程实质上是没有充分利用多核 CPU 的。
  + 异步转同步

## 异步编程解决方案
+ 目前，异步编程的主要解决方案有如下3种：
  + 事件发布/订阅模式；
  + Promise/Deferred 模式；
  + 流程控制库；

### 事件发布/订阅模式
+ Node 自身提供的 events 模块是发布/订阅模式的一个简单实现。
+ 事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件监听器。
+ 事件发布/订阅模式自身并无同步与异步调用的问题，但在 Node 中，emit() 调用多半是伴随事件循环而异步触发的，所以我们说事件发布/订阅模式广泛应用于异步编程。
+ 在一些典型场景中，可以通过事件发布/订阅模式进行组件封装，将不变的部分封装在组件内部，将容易变化、需自定义的部分通过事件暴露给外部处理，这是一种典型的逻辑分离方式。
+ 事件监听器模式也是一种钩子（hook）机制，利用钩子勾出内部数据或状态给外部的调用者。

### Promise/Deferred 模式
+ Promise 对单个抽象操作的定义
  + Promise 操作只会处在 3 种状态中的一种：未完成态、完成态和失败态。
  + Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。
  + Promise 的状态一旦转化，将不能被更改。
+ Deferred 主要是用于内部，用于维护异步模型的状态（不变的部分）；Promise 则作用于外部，通过 then() 方法暴露给外部以添加自定义逻辑。
+ 让 Promise 支持链式调用的方法
  + 将所有的回调都存到队列中；
  + Promise 完成时，逐个执行回调，一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它；

### 流程控制库
+ 尾触发与 Next
  + 这一类方法是需要手动调用此案持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是 next。
  + 在通过 use() 方法注册好一系列中间件后，监听端口上的请求。中间件利用了尾触发的机制，最简单的中间件如下：
  ```es6
  function(req, res, next) {
    // 中间件
  }
  ```
  + 每个中间件传递请求对象、响应对象和尾触发函数，通过队列形成一个处理流。
  + 中间件机制使得在处理网络请求时，可以像面向切面编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联，以致产生耦合。
  + 尾触发十分适合处理网络请求的场景。将复杂的处理逻辑拆解为简洁、单一的处理单元，逐层次地处理请求对象和响应对象。
+ async（是个库，不是 es7 那个 async）
+ Step（与 async 库类似）;
+ wind（eval 实现了 await 效果）；

## 异步并发控制
+ bagpipe 的解决方案
  + 通过一个队列来控制并发量；
  + 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行；
  + 如果活跃调用达到限定值，调用暂时存放在队列中；
  + 每个异步调用结束时，从队列中取出新的异步调用执行；
  + 异步调用的并发限制在不同场景下的需求不同：非实时场景下，让超出限制的并发暂时等待执行依据可以满足需求；但在实时场景下，需要更细粒度、更合理的控制。
+ async 的解决方案：限制并发