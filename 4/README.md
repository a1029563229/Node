# 异步编程

## 函数式编程
+ 高阶函数
  + 高阶函数可以把函数作为参数，或者将函数作为返回值的函数。

## 异步编程的优势与难点
+ 优势
  + Node 利用 Javascript 及其内部异步库，将异步直接提升到业务层面，这是一种创新。
  + 非阻塞 I/O 可以使 CPU 与 I/O 并不相互依赖等待，让资源得到更好的利用。
  + 只要合理利用 Node 的异步模型和 V8 的高性能，就可以充分发挥 CPU 和 I/O 资源的优势。
+ 难点
  + 异常处理
    + Node 在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出。
  + 函数嵌套过深
  + 阻塞代码
  + 多线程编程
    + 对于服务端而言，如果服务器是多核 CPU，单个 Node 进程实质上是没有充分利用多核 CPU 的。
  + 异步转同步

## 异步编程解决方案
+ 目前，异步编程的主要解决方案有如下3种：
  + 事件发布/订阅模式；
  + Promise/Deferred 模式；
  + 流程控制库；

### 事件发布/订阅模式
+ Node 自身提供的 events 模块是发布/订阅模式的一个简单实现。
+ 事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件监听器。
+ 事件发布/订阅模式自身并无同步与异步调用的问题，但在 Node 中，emit() 调用多半是伴随事件循环而异步触发的，所以我们说事件发布/订阅模式广泛应用于异步编程。
+ 在一些典型场景中，可以通过事件发布/订阅模式进行组件封装，将不变的部分封装在组件内部，将容易变化、需自定义的部分通过事件暴露给外部处理，这是一种典型的逻辑分离方式。
+ 事件监听器模式也是一种钩子（hook）机制，利用钩子勾出内部数据或状态给外部的调用者。

### Promise/Deferred 模式
+ Promise 对单个抽象操作的定义
  + Promise 操作只会处在 3 种状态中的一种：未完成态、完成态和失败态。
  + Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。
  + Promise 的状态一旦转化，将不能被更改。
+ Deferred 主要是用于内部，用于维护异步模型的状态（不变的部分）；Promise 则作用于外部，通过 then() 方法暴露给外部以添加自定义逻辑。