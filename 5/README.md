# 内存控制

## V8 的垃圾回收机制与内存限制
+ Node 是一个构建在 Chrome 的 Javascript 运行时上的平台，V8 作为 Node 的 Javascript 脚本引擎，给 Node 带来了性能的优势。
+ 在 Node 中通过 Javascript 使用内存时会发现只能使用部分内存（64 位系统下约为 1.4 GB，32 位系统下约为 0.7 GB），这是因为 Node 中使用的 Javascript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。
+ process.memoryUsage() 可查看内存相关信息；

### V8 的垃圾回收机制
+ V8 主要的垃圾回收算法
  + 在实际的应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果。现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行了不同的分代，然后分别对不同分代的内存施以更高效的算法。
  + 在 V8 中，主要讲内存分为新生代与老生代两代。新生代中的对象为存货时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。V8 堆的整体大小就是新生代所用内存空间加上老生代的内存空间。
  + 新生代内存的最大值在 64 位系统和 32 位系统上分别为 32MB 和 16MB。
+ Scavenge 算法
  + 在分代的基础上，新生代中的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 算法的具体实现中，主要采用了 Cheney 算法。
  + Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存货对象将会被复制到 To 空间，而非存活对象占用的空间将会被释放。完成复制后，From 空间与 To 空间的角色发生转换。
  + Scavenge 的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但 Scavenge 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。
  + 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。
  + 对象晋升的条件主要有两个，一个是对象是否经理过 Scavenge 回收，一个是 To 空间的内存占用比超过限制。
+ Mark-Sweep 和 Mark-Compact
  + Mark-Sweep 是标记清除的意思，它分为标记和清除两个阶段。Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。（不划分内存空间，不存在浪费一半空间的行为）（活对象在新生代中只占较小部分，死对象在老生代中只占较小部分）
  + Mark-Sweep 最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。
  + Mark-Compact 是标记整理的意思，它会在标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。 
  + V8 主要使用 Mark-Sweep，在空间不足时才使用 Mark-Compact。
+ 为防止“全停顿”式垃圾回收造成程序阻塞，V8 引入了增量标记、延迟清理和增量式清理。

## 高效使用内存
+ 在 Javascript 中能形成作用域的有函数调用、with 以及全局作用域。
+ 如果想主动释放变量引用的对象，只需要将变量重新赋值。
+ 在 Javascript 中，实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）。这得益于高阶函数的特性：函数可以作为参数或返回值。
+ 在正常的 Javascript 执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于 V8 的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。

## 内存指标
```es6
// 查看 Node 进程的内存使用情况
// 返回值中 rss 是进程的常驻内存，heapTotal 是堆中总共申请的内存量，heapUsed 表示目前堆中使用的内存量
process.memoryUsage();

// 查看系统总内存和限制内存
os.totalmem();
os.freemem();
```
Node 的内存构成主要由通过 V8 进行分配的部分和 Node 自行分配的部分。受 V8 的垃圾回收限制的主要是 V8 的堆内存。

## 内存泄露
+ 通常造成内存泄露的原因
  + 缓存；
  + 队列消费不及时；
  + 作用域未释放；
+ 缓存或是别的模式，都应该具有一个完备的解决方案。
+ 排查内存泄露的原因主要通过对堆内存进行分析而找到。node-heapdump 和 node-memwatch 各有所长，可以结合着使用。
+ 读写大文件时，可以尝试进行纯粹的 Buffer 操作，这不会受到 V8 堆内存的限制。