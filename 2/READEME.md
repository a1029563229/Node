# 模块机制

## CommonJS 规范
+ Javascript 早期的缺陷：
  + 没有模块系统
  + 标准库较少
  + 没有标准接口
  + 缺乏包管理系统
+ CommonJS 的模块规范
  + 模块引用：const math = require('math');
  + 模块定义：module.exports = math;
  + 模块标识
+ Node 引入模块，需要经历3个步骤
  + 路径分析
  + 文件定位
  + 编译执行

## Node 中的模块实现
+ Node 中的两类模块
  + 核心模块：核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它是加载速度是最快的。
  + 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。
+ 与前端浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。
+ 模块标识符
  + 核心模块：核心模块的优先级仅次于缓存加载，它在 Node 源代码编译过程中已经编译为二进制代码，其加载过程最快。
  + 路径形式的文件模块：以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析路径模块时，require() 方法会将路径转为真实路径，并以真实路径为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。
  + 自定义模块：自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。在加载过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件或到达最顶级目录仍未找到文件为止。寻找路径如下
    + 当前文件目录下的 node_modules 目录；
    + 父目录下的 node_modules 目录；
    + 父目录的父目录下的 node_modules 目录；
    + 沿路径向上逐级递归，直到根目录下的 node_modules 目录；